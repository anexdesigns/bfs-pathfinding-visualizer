{"version":3,"sources":["components/algorithm/Algorithm.js","components/visualizer/Visualizer.js","components/visualizer/Node.js","App.js","index.js"],"names":["shortestPath","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","visitedNodesArray","locationStatus","location","grid","startNode","finishNode","gridHeight","length","gridWidth","row","column","isWall","isVisited","Node","this","props","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","PathfindingVisualizer","state","mouseIsPressed","createStartNode","createFinishNode","getInitialGrid","setState","window","reload","newGrid","getNewGridWithStartToggled","getNewGridWithFinishToggled","getNewGridWithWallToggled","visitedNodesInOrder","shortestPathNodes","solution","i","setTimeout","animateShortestPath","node","document","getElementById","queue","path","status","currentLocation","shift","possibleNodes","currentRow","currentColumn","north","south","west","east","push","newPath","slice","newLocation","breadthFirstSearch","animateBFS","onClick","clearGrid","visualizeBFS","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","React","createNode","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.1bc32aca.chunk.js","sourcesContent":["\nexport function breadthFirstSearch(startNode, finishNode, grid) {\n\n     let row = startNode.row\n     let column = startNode.column\n\n     // Each \"location\" will store its coordinates and the shortest path required to arrive there\n     let location = {\n          row: row,\n          column: column,\n          path: [],\n          status: 'Start'\n     };\n\n     // Initialize the queue with the start location already inside\n     const queue = [location]\n\n     // Loop through the grid searching for the goal\n     while (queue.length > 0) {\n\n          let currentLocation = queue.shift();\n\n          const possibleNodes = []\n\n          let currentRow = currentLocation.row\n          let currentColumn = currentLocation.column\n\n          const north = [currentRow - 1, currentColumn]\n          const south = [currentRow + 1, currentColumn]\n          const west = [currentRow, currentColumn - 1]\n          const east = [currentRow, currentColumn + 1]\n\n          possibleNodes.push(north, east, south, west)\n\n          // console.log(possibleNodes)\n\n          // For each valid Node, it checks north, south, east and west\n          for (let i = 0; i < possibleNodes.length; i++) {\n\n               let newPath = currentLocation.path.slice();\n               newPath.push(possibleNodes[i])\n\n               let newLocation = {\n                    row: possibleNodes[i][0],\n                    column: possibleNodes[i][1],\n                    path: newPath,\n                    status: 'Unkown'\n               }\n\n               // Checks whether the node is Invalid, Blocked, Valid, or the Goal\n               newLocation.status = locationStatus(newLocation, grid, startNode, finishNode);\n\n               // If this new location is valid, mark it as 'Visited' and continue searching\n               if (newLocation.status === 'Valid') {\n                    visitedNodesArray.push(newLocation)\n                    grid[newLocation.row][newLocation.column].isVisited = true\n                    queue.push(newLocation)\n               }\n\n               if (newLocation.status === 'Goal') {\n                    shortestPath = newLocation.path\n                    return true\n               }\n          }\n\n     }\n     // No valid path found\n     return false;\n}\n\nexport const visitedNodesArray = []\n// console.log(visitedNodesArray)\nexport let shortestPath;\n\nlet locationStatus = (location, grid, startNode, finishNode) => {\n     const gridHeight = grid.length;\n     const gridWidth = grid[0].length\n     let row = location.row;\n     let column = location.column;\n\n     if (location.column < 0 || location.column >= gridWidth || location.row < 0 || location.row >= gridHeight) {\n          return 'Invalid';\n     } else if (grid[row][column] === finishNode) {\n          return 'Goal';\n     } else if (grid[row][column].isWall === true || grid[row][column].isVisited === true || grid[row][column] === startNode) {\n          return 'Blocked'\n     } else {\n          return 'Valid'\n     }\n}\n","import React from 'react';\nimport '../style/Visualizer.css'\nimport { breadthFirstSearch, visitedNodesArray, shortestPath } from '../algorithm/Algorithm.js';\nimport Node from './Node'\n\n/* \n     High Level View:\n     1.) On componentDidMount, the grid (which is a 2D array) gets created by calling getInitialGrid()\n     2.) When \"Go!\" is clicked, it sends off the current state of the grid, the starting node, and the finish node to breadthFirstSearch() in Algorithm.js\n     3.) Returns false if no path is found. If path is found, it populates shortestPath and visitedNodesArray. shortestPath is an array of coordinates and visitedNodesArray is an array of nodes that were visited in order.\n     4.) Takes the result and then calls animateBFS()\n*/\n\n\nlet START_NODE_ROW;\nlet START_NODE_COL;\nlet FINISH_NODE_ROW\nlet FINISH_NODE_COL;\n\n\nexport default class PathfindingVisualizer extends React.Component {\n     constructor() {\n          super();\n          this.state = {\n               grid: [],\n               mouseIsPressed: false,\n               createStartNode: false,\n               createFinishNode: false\n          };\n     }\n\n     // Create the blank grid and change the current state to that grid\n     componentDidMount() {\n          const grid = getInitialGrid();\n          this.setState({ grid: grid });\n     }\n\n     clearGrid() {\n          window.location.reload(false)\n     }\n\n     createStartNode() {\n          // Create a start node only if there is NOT already a start node\n          if (!START_NODE_ROW && !START_NODE_COL) {\n               this.setState({ createStartNode: true, createFinishNode: false })\n          }\n     }\n\n     createFinishNode() {\n          // Create a finish node only if there is NOT already a finish node\n          if (!FINISH_NODE_ROW && !FINISH_NODE_COL) {\n               this.setState({ createFinishNode: true, createStartNode: false })\n          }\n     }\n\n     // When the mouse is pushed down on the grid, create either a wall, start, or finish\n     handleMouseDown(row, column) {\n          if (this.state.createStartNode) {\n               const newGrid = getNewGridWithStartToggled(this.state.grid, row, column)\n               this.setState({ grid: newGrid, createStartNode: false });\n\n          } else if (this.state.createFinishNode) {\n               const newGrid = getNewGridWithFinishToggled(this.state.grid, row, column)\n               this.setState({ grid: newGrid, createFinishNode: false });\n\n          } else {\n               const newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n               this.setState({ grid: newGrid, mouseIsPressed: true });\n          }\n\n     }\n\n     // Enables the user to click and drag to create walls\n     handleMouseEnter(row, column) {\n          if (!this.state.mouseIsPressed) return;\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, column);\n          this.setState({ grid: newGrid });\n     }\n\n     handleMouseUp() {\n          this.setState({ mouseIsPressed: false });\n     }\n\n     // First animates the visited nodes, then the shortest path.\n     animateBFS(visitedNodesInOrder, shortestPathNodes, solution) {\n          for (let i = 0; i < visitedNodesInOrder.length; i++) {\n               // If animation is done, call the worker function that animates shortest path\n               if (i === visitedNodesInOrder.length - 1) {\n                    if (solution) {\n                         setTimeout(() => {\n                              this.animateShortestPath(shortestPathNodes);\n                         }, 25 * i);\n                         return;\n                    }\n               }\n               // Animates visited nodes\n               setTimeout(() => {\n                    const node = visitedNodesInOrder[i];\n                    document.getElementById(`node-${node.row}-${node.column}`).className =\n                         'node node-visited';\n               }, 25 * i);\n          }\n     }\n\n     animateShortestPath(shortestPathNodes) {\n          for (let i = 0; i < shortestPathNodes.length - 1; i++) {\n               setTimeout(() => {\n                    const node = shortestPathNodes[i];\n                    document.getElementById(`node-${node[0]}-${node[1]}`).className =\n                         'node node-shortest-path';\n               }, 130 * i);\n          }\n     }\n\n     visualizeBFS() {\n          // Checks to see if user picked a start node and finish node\n          if (START_NODE_ROW && START_NODE_COL && FINISH_NODE_ROW && FINISH_NODE_COL) {\n               const { grid } = this.state;\n\n               const startNode = grid[START_NODE_ROW][START_NODE_COL]\n               const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n\n               // Returns true or false depending if a shortest path was found\n               const solution = breadthFirstSearch(startNode, finishNode, grid)\n\n               this.animateBFS(visitedNodesArray, shortestPath, solution);\n          }\n     }\n\n     render() {\n          const { grid, mouseIsPressed } = this.state;\n          return (\n               <div className=\"main-container\">\n                    <div className=\"header\">\n                         <h1 className=\"title\">Breadth First Search Algorithm - Pathfinding Visualizer</h1>\n                         <div className=\"button-container\">\n                              <button onClick={() => this.clearGrid()} className=\"clear-button\">Clear</button>\n                              <button onClick={() => this.visualizeBFS()} className=\"visualize-button\">Go!</button>\n                              <button onClick={() => this.createStartNode()} className=\"startNode-button\">Choose Start Node</button>\n                              <button onClick={() => this.createFinishNode()} className=\"finishNode-button\">Choose End Node</button>\n                         </div>\n                    </div>\n                    <div className=\"grid-container\">\n                         <div className=\"grid\">\n                              {grid.map((row, rowIdx) => {\n                                   return (\n                                        <div key={rowIdx}>\n                                             {row.map((node, nodeIdx) => {\n                                                  const { row, column, isFinish, isStart, isWall } = node;\n                                                  return (\n                                                       <Node\n                                                            key={nodeIdx}\n                                                            column={column}\n                                                            isFinish={isFinish}\n                                                            isStart={isStart}\n                                                            row={row}\n                                                            isWall={isWall}\n                                                            mouseIsPressed={mouseIsPressed}\n                                                            onMouseDown={(row, column) => this.handleMouseDown(row, column)}\n                                                            onMouseEnter={(row, column) => this.handleMouseEnter(row, column)}\n                                                            onMouseUp={() => this.handleMouseUp()}\n                                                       ></Node>\n                                                  );\n                                             })}\n                                        </div>\n                                   );\n                              })}\n                         </div>\n                    </div>\n               </div>\n          )\n     }\n}\n\n// Creates a plain grid that is represented by a 2D array\nconst getInitialGrid = () => {\n     const gridwidth = 45;\n     const gridHeight = 18;\n     const grid = [];\n     for (let row = 0; row < gridHeight; row++) {\n          const currentRow = [];\n          for (let column = 0; column < gridwidth; column++) {\n               currentRow.push(createNode(column, row));\n          }\n          grid.push(currentRow);\n     }\n     return grid;\n};\n\n// Information that each node will have\nconst createNode = (column, row) => {\n     return {\n          column,\n          row,\n          isStart: false,\n          isFinish: row === FINISH_NODE_ROW && column === FINISH_NODE_COL,\n          isVisited: false,\n          isWall: false\n     }\n}\n\n// Create a new grid that has walls\nconst getNewGridWithWallToggled = (grid, row, column) => {\n     const newGrid = grid.slice();\n     const node = newGrid[row][column];\n     const newNode = {\n          ...node,\n          isWall: !node.isWall,\n     };\n     newGrid[row][column] = newNode;\n     return newGrid;\n};\n\n// Create a new grid that has a start\nconst getNewGridWithStartToggled = (grid, row, column) => {\n     const newGrid = grid.slice();\n     const node = newGrid[row][column];\n     const newNode = {\n          ...node,\n          isStart: !node.isStart\n     }\n     newGrid[row][column] = newNode;\n     START_NODE_ROW = row;\n     START_NODE_COL = column;\n     return newGrid;\n}\n\n// Create a new grid that has a finish\nconst getNewGridWithFinishToggled = (grid, row, column) => {\n     const newGrid = grid.slice();\n     const node = newGrid[row][column];\n     const newNode = {\n          ...node,\n          isFinish: !node.isFinish\n     }\n     newGrid[row][column] = newNode;\n     FINISH_NODE_ROW = row;\n     FINISH_NODE_COL = column;\n     return newGrid;\n}\n","import React, { Component } from 'react';\nimport '../style/Node.css'\n\n\nexport default class Node extends Component {\n     render() {\n          const {\n               column,\n               isFinish,\n               isStart,\n               row,\n               isWall,\n               onMouseDown,\n               onMouseEnter,\n               onMouseUp\n          } = this.props;\n          const extraClassName = isFinish\n               ? 'node-finish'\n               : isStart\n                    ? 'node-start'\n                    : isWall\n                         ? 'node-wall'\n                         : '';\n\n          return (\n               <div\n                    id={`node-${row}-${column}`}\n                    className={`node ${extraClassName}`}\n                    onMouseDown={() => onMouseDown(row, column)}\n                    onMouseEnter={() => onMouseEnter(row, column)}\n                    onMouseUp={() => onMouseUp()}\n               ></div>\n          );\n     }\n}\n\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './components/visualizer/Visualizer'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {/* <h1>Breadth First Search Algorithm - Pathfinding Visualizer</h1> */}\n      < PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n"],"sourceRoot":""}